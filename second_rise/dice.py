import random
import operator

# Constants
MOD_OPERATORS = {'PLUS': operator.add,
                 'MINUS': operator.sub,
                 'MULTIPLIED_BY': operator.mul,
                 'DIVIDED_BY': operator.truediv,
                 '+': operator.add,
                 '-': operator.sub,
                 '*': operator.mul,
                 '/': operator.truediv}


class Die(object):
    """ Represents a die.  The die is '.roll()'ed to determine a random value

    Attributes:
        _sides: an integer representing the number of sides on the die.
        _result: an integer representing the last rolled value of the die.
        _minimum: an integer representing the lowest value the dice can
            generate.  The maximum is therefore self._minimum + self._sides -1.

    To Do:
        Add result _future_, and undo/redo (future is what the current roll
        would become if you undo to a step back in _history.
    """
    def __init__(self, sides, minimum=1):
        """ Build a new die.  Ignore all 'sides' argument values other than but
        positive integers.  For invalid 'sides' arguments, set the side count to
        0, to represent an error/misconfiguration state.

        Arguments:
            sides (int): the number of sides on the die.
            minimum (int): an integer representing the lowest value the dice
            can generate.
        """
        self._sides = 0
        self._result = None
        self._minimum = minimum
        if sides > 0:
            self._sides = sides
        self._history = []

    @property
    def valid(self):
        """ Check whether the die has a valid number of sides. """
        return self._sides != 0

    @property
    def rolled(self):
        """ Check whether the die has been rolled. """
        return self._result is not None

    @property
    def sides(self):
        """ Get the die's number of sides. """
        return self._sides

    @property
    def average(self):
        """ Get the average result generated by rolling this die """
        if not self.valid:
            return 0
        else:
            return (self._sides + 1) / 2

    @property
    def result(self):
        """ Get the die's last rolled result. """
        return self._result

    @property
    def minimum(self):
        """Get the die's minimum value. """
        return self._minimum

    @property
    def maximum(self):
        """ Get the die's maximum value."""
        return self._minimum + self._sides - 1

    def roll(self):
        """ 'Roll' the dice and store the result. move any previous results
        to the die's history.
        """
        if self.rolled:
            self._history.append(self.result)
        self._result = random.randint(1, self._sides) + self._minimum - 1

    @property
    def history(self):
        return self._history

    def clear_history(self):
        """ Clears the die' roll history. """
        self._history = []

    def __str__(self, verbose=False):
        """ Return either the die value as a string (terse) or a more
        detailed response (verbose).

        Arguments:
            verbose: a boolean value representing whether or not the return
            value should be verbose.
        """
        if not verbose:
            return str(self._result)
        return 'd{}: {}'.format(self._sides, self._result)

    def __unicode__(self, verbose=False):
        return self.__str__(verbose)


class D10(Die):
    """ Convenience sub-class of Die, creates a 10-sider.
    Results range is 1-10.
    """
    def __init__(self):
        Die.__init__(self, 10)


class D5(Die):
    """ Convenience sub-class of Die, creates a 5-sider.
    Results range is 1-5.
    """
    def __init__(self):
        Die.__init__(self, 5)


class D2(Die):
    """ Convenience sub-class of Die, creates a 2-sider.
    Results range is 1-2.
    """
    def __init__(self):
        Die.__init__(self, 2)


class D100(Die):
    """ Convenience sub-class of Die, creates a 100-sider.
    Results range is 1-100.  This is _not_ a percentile dice.
    """
    def __init__(self):
        Die.__init__(self, 100)


class Percentile(Die):
    """ A compound dice construct, using two D10 objects to generate a range
    of results from either 0-99 or 1-100, using one die as the tens digit and
    one die as the ones digit.

    Attributes:
        _minimum: an integer representing the the minimum value of a roll -
        either 1 or 0.
        _dice: a list holding the individual Die objects that comprise the
        compound dice construct.
        _history: a list containing all previous roll results
        _average: the average roll result for the compound die.

    To Do:
        Add result _future_, and undo/redo (future is what the current roll
        would become if you undo to a step back in _history.
    """
    def __init__(self, minimum=1):
        # Minimum can only be 0 or 1.  Some systems use percentile dice to
        # represent 0-99 instead of 1-100.  Using minimum = 0 allows the
        # alternate use.  Only minimum values of 0 and 1 are allowed.
        if minimum != 0:
            minimum = 1
        self._minimum = minimum
        self._dice = [D10(), D10()]
        # self._dice.append(D10())
        # self._dice.append(D10())
        self._average = 0
        self._history = []

    def roll(self):
        """ Rolls both d10 to generate a percentile score. """
        if self.rolled:
            self._history.append(self.result)
        for die in self._dice:
            die.roll()

    @property
    def dice(self):
        """ Return the dice that make up the compound die. """
        return self._dice

    @property
    def rolled(self):
        """ Check to see if both dice have been rolled """
        answer = True
        for die in self.dice:
            if not die.rolled:
                answer = False
        return answer

    @property
    def valid(self):
        """ Check to ensure that both dice have a valid number of sides. """
        answer = True
        for die in self.dice:
            if not die.valid:
                answer = False
        return answer

    @property
    def sides(self):
        """ Return the number of sides represented by the compound dice
        construct. """
        sides = 1
        for die in self.dice:
            sides *= die.sides
        return sides

    @property
    def average(self):
        """ Calculate and return the average roll result of a percentile-style
        compound dice, including accounting for min-1 versus min-0 dice.
        """
        if self.minimum == 1:
            modifier = 1
        else:
            modifier = -1
        return (self.sides + modifier) / 2

    @property
    def tens(self):
        """ Return the d10 used for the tens-digit. """
        return self._dice[1]

    @property
    def ones(self):
        """ Return the d10 used to represent the ones-digit. """
        return self.dice[0]

    @property
    def minimum(self):
        """ Return the minimum roll result. """
        return self._minimum

    @property
    def maximum(self):
        """ Return the maximum roll result. """
        return self.minimum + self.sides - 1

    @property
    def result(self):
        """ Return the percentile pair's rolled result. """
        if not self.rolled:
            return 0
        # Check if an all 10s result was rolled.  On physical dice,
        # that would correspond to an all-zeros roll, which is either a maximum
        # or minimum roll, depending on whether the minimum roll is 0 or 1.
        multiplier = 1
        total = 0
        for die in self._dice:
            # Get the value of each die in order
            die_value = 0
            if die.result != 10:
                die_value = die.result
            # Add the die's value to the overall total, adjusting for digit
            # represented
            total += die_value * multiplier
            # Adjust the multiplier to represent the next digit
            multiplier *= 10
        if total == self.maximum and self._minimum == 0:
            return 0
        else:
            return total

    def __str__(self, verbose=False):
        """ Return either the die value as a string (terse) or a more
        detailed response (verbose).

        Arguments:
            verbose: a boolean value representing whether or not the return
            value should be verbose.
        """
        if not verbose:
            return str(self.result)
        side_count = 1
        for die in self._dice:
            side_count *= die.sides
        return 'd{}: {}'.format(side_count, self.result)


class D1000(Percentile):
    """ A compound dice for generating 0-999 or 1-1000 using three d10."""
    def __init__(self, minimum=1):
        Percentile.__init__(self, minimum)
        self._dice.append(D10())

    @property
    def hundreds(self):
        """ Return the d10 used for the hundreds-digit. """
        return self._dice[2]


class D10000(D1000):
    """ A compound dice for generating 0-9999 or 1-10000 using four d10."""
    def __init__(self, minimum=1):
        D1000.__init__(self, minimum)
        self._dice.append(D10())

    @property
    def thousands(self):
        """ Return the d10 used for the hundreds-digit. """
        return self._dice[3]


class Range(object):
    """ Represents a dice-result range, constructed from modifiers and one or
    more d10.

    Attributes:
        _minimum: an integer representing the minimum possible result allowed
        by the range.
        _maximum: an integer representing the maximum possible result allowed
        by the range.  Maximum must be higher than minimum.
        _dice: a list containing the Die.D10 objects used to generate values
        within the range.

    To Do:
        Add result _future_, and undo/redo (future is what the current roll
        would become if you undo to a step back in _history.
        Add result probability table.
    """

    def __init__(self, minimum, maximum, dice_count=0):
        # Force maximum to be greater than minimum.
        if maximum <= minimum:
            maximum = minimum + 1
        # Set default dice value to be equal to the minimum.
        if dice_count == 0:
            dice_count = minimum
        self._minimum = minimum
        self._maximum = maximum
        self._dice = []
        for i in range(0, dice_count):
            self._dice.append(D10())
        self._history = []

    @property
    def minimum(self):
        return self._minimum

    @minimum.setter
    def minimum(self, minimum):
        self._minimum = minimum

    @property
    def maximum(self):
        return self._maximum

    @maximum.setter
    def maximum(self, maximum):
        self._maximum = maximum

    @property
    def dice(self):
        return self._dice

    @property
    def dice_count(self):
        """ Return the number of dice assigned to generate values within
        the range.
        """
        return len(self._dice)

    @dice_count.setter
    def dice_count(self, dice_count):
        """ Change the number of dice assigned to generate values within
        the range.
        """
        self._dice = []
        for i in range(1, dice_count):
            self._dice.append(D10())

    @property
    def dice(self):
        return self._dice

    @property
    def rolled(self):
        """ Check to see if both dice have been rolled """
        answer = True
        for die in self.dice:
            if not die.rolled:
                answer = False
        return answer

    @property
    def valid(self):
        """ Check to ensure that both dice have a valid number of sides. """
        answer = True
        for die in self.dice:
            if not die.valid:
                answer = False
        return answer

    def roll(self):
        """ Rolls both d10 to generate a percentile score. """
        if self.rolled:
            self._history.append(self.result)
        for die in self._dice:
            die.roll()

    def dice_sort(self):
        """ Sort the dice in self._dice by value, placing the
        highest at [0].
        """
        sorted(self._dice, key=lambda die: die.result)

    def build_total(self, dice_to_exclude=0):
        """ Total all dice results, minus any that have been excluded."""
        if not self.rolled:
            return 0
        total = 0
        for die in self._dice[dice_to_exclude:len(self._dice)]:
            total += die.result
        return total

    @property
    def result(self):
        """ Compute the result of a roll made 'against' the range. """
        dice_to_exclude = 0
        # Total the values of the rolled dice
        total = self.build_total(0)
        # If the total is greater than the maximum, iteratively exclude the
        # die with the lowest value until the total is not greater than the
        # maximum.
        while total > self._maximum:
            dice_to_exclude += 1
            total = self.build_total(dice_to_exclude)
        # If the total is _less_ than the minimum, but not zero,
        # set it to the  minimum
        if 0 < total <= self._minimum:
            total = self.minimum
        return total

    @property
    def history(self):
        return self._history

    def clear_history(self):
        """ Clears the die's roll history. """
        self._history = []

    def __str__(self, verbose=False):
        """ Return either the die value as a string (terse) or a more
        detailed response (verbose).

        Arguments:
            verbose: a boolean value representing whether or not the return
            value should be verbose.
        """
        if not verbose:
            return str(self.result)
        return 'range {}-{} (using {}d10): {}'.format(self.minimum,
                                                      self.maximum,
                                                      self.dice_count,
                                                      self.result)

    def __unicode__(self, verbose=False):
        return self.__str__(verbose)
